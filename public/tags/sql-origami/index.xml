<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SQL Origami on Hugo Quick Start Site</title>
    <link>https://example.org/tags/sql-origami/</link>
    <description>Recent content in SQL Origami on Hugo Quick Start Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Mar 2009 12:13:00 -0700</lastBuildDate>
    <atom:link href="https://example.org/tags/sql-origami/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LINQ to SQL Roundtrips: SQL Trace</title>
      <link>https://example.org/2009/03/linq-to-sql-roundtrips-sql-trace.html</link>
      <pubDate>Fri, 27 Mar 2009 12:13:00 -0700</pubDate>
      <guid>https://example.org/2009/03/linq-to-sql-roundtrips-sql-trace.html</guid>
      <description>I was looking into reducing the number of database round trips that LINQ to SQL took and found an article by David Hayden that fit the bill. I wanted to see what was actually happening so I slapped together a simple demo.&#xA;Using the Pubs database I created a console app, added the LINQ to SQL classes then created a simple repository class:&#xA;public class AuthorRepository { public author GetAuthorWithTitles(string authorId) { var db = new PubsDataClassesDataContext(); return db.</description>
    </item>
    <item>
      <title>SQL Moment of Clairity</title>
      <link>https://example.org/2006/10/sql-moment-of-clairity.html</link>
      <pubDate>Tue, 17 Oct 2006 12:16:00 -0700</pubDate>
      <guid>https://example.org/2006/10/sql-moment-of-clairity.html</guid>
      <description>I was working on a stored procedure the other day, not one that I wrote originally but one that was causing performance issues in out system. The procedure was taking any where from 40 to 60 seconds to run, which is unacceptable in a web service. This in fact was causing the web service to time out.&#xA;An inspection of the execution plan showed that one part of the procedure was doing an index scan and that it was this that was taking up over 85% of the execution time.</description>
    </item>
    <item>
      <title>SqlAssist, SQL Intellisense</title>
      <link>https://example.org/2006/04/sqlassist-sql-intellisense.html</link>
      <pubDate>Sat, 22 Apr 2006 20:41:00 -0700</pubDate>
      <guid>https://example.org/2006/04/sqlassist-sql-intellisense.html</guid>
      <description>SqlAssist, SQL Intellisense.&#xA;SqlAssist offers advanced SQL intellisense and script debugging inside the Microsoft Visual Studio .NET IDE.&#xA;Edit, test, and run scripts just like you do in SQL Server Management Studio. Use SQL pretty formatting, user configurable code templates, and many shortcuts all designed to enhance your SQL coding experience and reduce development time.&#xA;This has got to be one of the coolest add-ins to Visual Studio I have found in a long time!</description>
    </item>
    <item>
      <title>Period Matrix</title>
      <link>https://example.org/2004/09/period-matrix.html</link>
      <pubDate>Sat, 25 Sep 2004 10:01:00 -0700</pubDate>
      <guid>https://example.org/2004/09/period-matrix.html</guid>
      <description>The Period Matrix table, Pd_Matrix, is used in calculating accounting period formulas. These formulas include current month, quarter or years activity or balance. These formulas can also be created using standard SQL functions but not all functions are common between SQL Server and MS Access. The Period Matrix has the advantage in that it can be used in any DBMS and it also can be used in table pivoting and folding.</description>
    </item>
    <item>
      <title>MS Access Pivots Part II</title>
      <link>https://example.org/2004/09/ms-access-pivots-part-ii.html</link>
      <pubDate>Sat, 25 Sep 2004 09:45:00 -0700</pubDate>
      <guid>https://example.org/2004/09/ms-access-pivots-part-ii.html</guid>
      <description>Pivoting a table on multiple columns with a crosstab query gets messy really fast. To eliminate the need for complicated Multiple Value Field Queries you can use the lowly IIF() function and the obscure CHOOSE() function to pivot a table.&#xA;Activity Table The table Activity used in this example has the following layout:&#xA;AcctID DeptID Class Year BeginBalance Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec The AcctID and DeptID refer to account and department numbers, which are a part of our fictitious company’s accounting key.</description>
    </item>
    <item>
      <title>MS Access Pivots Part I</title>
      <link>https://example.org/2004/09/ms-access-pivots-part-i.html</link>
      <pubDate>Sat, 25 Sep 2004 09:35:00 -0700</pubDate>
      <guid>https://example.org/2004/09/ms-access-pivots-part-i.html</guid>
      <description>CrossTab queries are an easy way in MS Access to pivot tables. They are limited in that you can only pivot on one field and can only aggregate one field.&#xA;As an example we look at Activity table in the Sample.mdb. If we were asked to show the January activity for each account - department combination for each year using a crosstab query, we would create the following SQL:&#xA;TRANSFORM Sum(Activity.</description>
    </item>
    <item>
      <title>Period Matirx Twisting</title>
      <link>https://example.org/2004/01/period-matirx-twisting.html</link>
      <pubDate>Fri, 30 Jan 2004 09:35:00 -0800</pubDate>
      <guid>https://example.org/2004/01/period-matirx-twisting.html</guid>
      <description>The Period Matrix table, Pd_Matrix, is used in calculating accounting period formulas. These formulas include current month, quarter or years activity or balance. These formulas can also be created using standard SQL functions but not all functions are common between SQL Server and MS Access. The Period Matrix has the advantage in that it can be used in any DBMS and it also can be used in table pivoting and folding.</description>
    </item>
  </channel>
</rss>
